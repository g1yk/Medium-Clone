import React, { Component, useState, useEffect } from 'react'
import { Link } from 'react-router-dom'
import axios from 'axios'


// export default class Authentication extends Component {


const Authentication = () => {
    const [email, setEmail] = useState('') 
    const [password, setPassword] = useState('') 
    const [isSubmitting, setIsSubmitting] = useState(false)
    // const [{response, isLoading, error}, doFetch] = useFetch('someurl')

    
    // const emailRef = useRef(null) 

    // we create email reference and its empty reference 
    // its mutable object which we can change, set and read
    // then we using this ref with ref={emailRef} in input
    // and then we can read value from emailRef.current.value
    // (!!) React can't read changes in current.value and its bad, 
    // we will have a lot of errors


    // useRef its a reference, not the best practice, because its mutuable value,
    // and react knows nothing about it
    // basically its access to DOM element with reference

    const handleSubmit = (e) => {
        e.preventDefault();
        console.log('data', email, password )
        // console.log('ref' , emailRef.current.value)
        setIsSubmitting(true) // isSubmiting == true, after user pressed the button
    }





    // It creates hook inside of our components
    // (0) <-- its default value, from default now "counter" value is 0
    // counter its local variable where I can use where i want to render value of counter
    // setCount its a function setter which change our counter
    // So counter - state, setCount - setState
    // So useState returns an array of 2 elements, 1 element - state, 2 - setter

    useEffect( () => {
        if (!isSubmitting) {
            return
        }
        axios('https://conduit.productionready.io/api/users/login/', {
            method: 'post',
            data: {
                user: {
                    email: 'qq@qq.com',
                    password: '123',
                }
            }
        }).then(res => {
            console.log('success', res)
            setIsSubmitting(false)
        }).catch(err => {
            console.log('error', err)
            setIsSubmitting(false)

        })
        //1st initial render and then every time after every render/rerender
        //useEffect calls after EACH RENDER
    }, ) 
    // Because useEffect depends only on email variable, we don't need 
    // call useEffect after EVERY render, thats why we can use [email]
    // so now useEffect will be called ONLY after email change, not other changes
    // [] empty array call only 1st initial render, that's all
    // in array we only adding dependencies


    // const handleCounter = () => {
    //     setUser({name: 'Foo'})
    //     // hooks allow us to save states between renders
    //     // authentication component don't know anything about state
    //     // everytime rerender calls we reading value from useState
    //     // everytime auth component rerender we getting value from useState(0)
    //     // components could be rerendered only if state or props changed
    //     // hooks working like a snapshots, we have render and inside of render we have 
    //     // some state and some props and that's all, then rerender happens
    //     // and its absolutely new function with new state, ex counter = 2, and new props
    //     // inside of this render state could not be changed!
    //     // when its changed it creates rerender and we getting new function and 
    //     // new state, 
    // }
    // console.log('user', user)


    return (
        <div className='auth-page'>
      
            <div className='container page'>
                <div className='row'>
                    <div className='col-md-6 offset-md-3 col-xs-12'>
                        <h1 className='text-xs-center'>Login</h1>
                        <p className='text-xs-center'>
                            <Link to='register'>Need an account?</Link>
                        </p>
                        <form onSubmit={handleSubmit}>
                            <fieldset>
                                <fieldset className='form-group'>
                                    <input
                                        type='email'
                                        className='form-control form-control-lg'
                                        placeholder='Email'
                                        // ref={emailRef}>
                                        value={email}
                                        onChange={e => setEmail(e.target.value)}>


                             {/* we reading from event - value from this input
                              and call setEmail and passing inside e.target.value,
                              which is value in the moment of our input */}
                                    </input>
                                </fieldset>

                                <fieldset className='form-group'>
                                    <input
                                        type='password'
                                        className='form-control form-control-lg'
                                        placeholder='Password'
                                        value={password}
                                        onChange={e => setPassword(e.target.value)}>
                                    </input>
                                </fieldset>
                                <button className='btn btn-lg btn-primary pull-xs-right'
                                    type='submit'
                                    disabled={isSubmitting}> 
                                    Sign in
                                    </button>
                            </fieldset>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    )
}

export default Authentication