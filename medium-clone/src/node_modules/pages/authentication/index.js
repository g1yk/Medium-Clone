import React, { Component, useState, useEffect } from 'react'
import { Link } from 'react-router-dom'
import axios from 'axios'
import useFetch from 'hooks/useFetch'


// export default class Authentication extends Component {


const Authentication = props => {
    const isLogin = props.match.path === '/login'
    const pageTitle = isLogin ? 'Sign in' : 'Sign up'
    const descriptionLink = isLogin ? '/register' : '/login'
    const descriptionText = isLogin ? 'Need an account?' : 'Have an account?'
    const apiUrl = isLogin ? '/users/login' : '/users'
    const [email, setEmail] = useState('')
    const [password, setPassword] = useState('')
    const [username, setUsername] = useState('')
    const [{ response, isLoading, error }, doFetch] = useFetch(apiUrl)

    console.log('fff', isLogin)


    // const emailRef = useRef(null) 

    // we create email reference and its empty reference 
    // its mutable object which we can change, set and read
    // then we using this ref with ref={emailRef} in input
    // and then we can read value from emailRef.current.value
    // (!!) React can't read changes in current.value and its bad, 
    // we will have a lot of errors


    // useRef its a reference, not the best practice, because its mutuable value,
    // and react knows nothing about it
    // basically its access to DOM element with reference

    const handleSubmit = (e) => {
        e.preventDefault();
        console.log('data', email, password)
        // console.log('ref' , emailRef.current.value)
        // setIsSubmitting(true) // isSubmiting == true, after user pressed the button

        const user = isLogin ? {email, password} : {email, password, username}
        doFetch({
            method: 'post',
            data: {
                user
            }
        })
    }





    // It creates hook inside of our components
    // (0) <-- its default value, from default now "counter" value is 0
    // counter its local variable where I can use where i want to render value of counter
    // setCount its a function setter which change our counter
    // So counter - state, setCount - setState
    // So useState returns an array of 2 elements, 1 element - state, 2 - setter


    // Because useEffect depends only on email variable, we don't need 
    // call useEffect after EVERY render, thats why we can use [email]
    // so now useEffect will be called ONLY after email change, not other changes
    // [] empty array call only 1st initial render, that's all
    // in array we only adding dependencies


    // const handleCounter = () => {
    //     setUser({name: 'Foo'})
    //     // hooks allow us to save states between renders
    //     // authentication component don't know anything about state
    //     // everytime rerender calls we reading value from useState
    //     // everytime auth component rerender we getting value from useState(0)
    //     // components could be rerendered only if state or props changed
    //     // hooks working like a snapshots, we have render and inside of render we have 
    //     // some state and some props and that's all, then rerender happens
    //     // and its absolutely new function with new state, ex counter = 2, and new props
    //     // inside of this render state could not be changed!
    //     // when its changed it creates rerender and we getting new function and 
    //     // new state, 
    // }
    // console.log('user', user)


    return (
        <div className='auth-page'>

            <div className='container page'>
                <div className='row'>
                    <div className='col-md-6 offset-md-3 col-xs-12'>
                        <h1 className='text-xs-center'>{pageTitle}</h1>
                        <p className='text-xs-center'>
                            <Link to={descriptionLink}>{descriptionText}</Link>
                        </p>
                        <form onSubmit={handleSubmit}>
                            <fieldset>

                                {!isLogin && (
                                         <fieldset className='form-group'>
                                         <input
                                             type='text'
                                             className='form-control form-control-lg'
                                             placeholder='Username'
                                             // ref={emailRef}>
                                             value={username}
                                             onChange={e => setUsername(e.target.value)}>
     
     
                                             {/* we reading from event - value from this input
                                   and call setEmail and passing inside e.target.value,
                                   which is value in the moment of our input */}
                                         </input>
                                     </fieldset>
                                )}


                                <fieldset className='form-group'>
                                    <input
                                        type='email'
                                        className='form-control form-control-lg'
                                        placeholder='Email'
                                        // ref={emailRef}>
                                        value={email}
                                        onChange={e => setEmail(e.target.value)}>


                                        {/* we reading from event - value from this input
                              and call setEmail and passing inside e.target.value,
                              which is value in the moment of our input */}
                                    </input>
                                </fieldset>

                                <fieldset className='form-group'>
                                    <input
                                        type='password'
                                        className='form-control form-control-lg'
                                        placeholder='Password'
                                        value={password}
                                        onChange={e => setPassword(e.target.value)}>
                                    </input>
                                </fieldset>
                                <button className='btn btn-lg btn-primary pull-xs-right'
                                    type='submit'
                                    disabled={isLoading}>
                                    {pageTitle}
                                    </button>
                            </fieldset>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    )
}

export default Authentication